#!/usr/bin/python
"""
Defines the MalConv architecture.
Adapted from https://arxiv.org/pdf/1710.09435.pdf
Things different about our implementation and that of the original paper:
 * The paper uses batch_size = 256 and
   SGD(lr=0.01, momentum=0.9, decay=UNDISCLOSED, nesterov=True )
 * The paper didn't have a special EOF symbol
 * The paper allowed for up to 2MB malware sizes,
   we use 1.0MB because of memory on a Titan X
 """
import os
import sys
import hashlib

import numpy as np
import tensorflow as tf
from keras import metrics
from tensorflow.keras.models import load_model
from tensorflow.keras.optimizers import SGD

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
model_path = os.path.join(module_path, "malconv.h5")

tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

'''
class MalConv:
    def __init__(self):
        self.batch_size = 100
        self.input_dim = 257  # every byte plus a special padding symbol
        self.padding_char = 256
        self.malicious_threshold = 0.5

        self.model = load_model(model_path)
        _, self.maxlen, self.embedding_size = self.model.layers[1].output_shape

        self.model.compile(
            loss="binary_crossentropy",
            optimizer=SGD(lr=0.01, momentum=0.9, nesterov=True, decay=1e-3),
            metrics=[metrics.binary_accuracy],
        )

    def extract(self, bytez):
        b = np.ones((self.maxlen,), dtype=np.int16) * self.padding_char
        bytez = np.frombuffer(bytez[: self.maxlen], dtype=np.uint8)
        b[: len(bytez)] = bytez
        return b

    def predict_sample(self, bytez):
        return self.model.predict(bytez.reshape(1, -1))[0][0]
'''

class MalConv:
    def __init__(self):
        self.batch_size = 100
        self.input_dim = 257  # every byte plus a special padding symbol
        self.padding_char = 256
        self.malicious_threshold = 0.5

        self.model = load_model(model_path)
        _, self.maxlen, self.embedding_size = self.model.layers[1].output_shape

        self.model.compile(
            loss="binary_crossentropy",
            optimizer=SGD(lr=0.01, momentum=0.9, nesterov=True, decay=1e-3),
            metrics=[metrics.binary_accuracy],
        )

    def extract(self, bytez):
        b = np.ones((self.maxlen,), dtype=np.int16) * self.padding_char
        bytez = np.frombuffer(bytez[: self.maxlen], dtype=np.uint8)
        b[: len(bytez)] = bytez
        return b

    def predict_sample(self, bytez):
        return self.model.predict(bytez.reshape(1, -1))[0][0]

    def fetch_file(self, sample_path):
        with open(sample_path, "rb") as f:
            bytez = f.read()
        return bytez


if __name__ == '__main__':
    '''
    directory = '/home/bamboo/桌面/malware_rl-main (2.0)/malware_rl-main/malware_rl/envs/utils/samples/all_benign/benign'  # 良性dll文件所在目录的路径
    malconv = MalConv()

    a = b = c = 0
    for filename in os.listdir(directory):
        if filename.endswith(".dll") or filename.endswith(".DLL") or filename.endswith(".exe"):  # 检查文件扩展名是否为.dll
            filepath = os.path.join(directory, filename)
            bytez = malconv.fetch_file(filepath)
            bytez_np = malconv.extract(bytez)
            prediction = malconv.predict_sample(bytez_np)
            a = a + 1
            print(f"File: {filename}, Prediction: {prediction}")

            # 根据预测结果决定是否删除文件
            if prediction >= malconv.malicious_threshold:
                os.remove(filepath)  # 删除文件
                print(f"Deleted: {filename} due to high prediction score.")
                b = b + 1
            else:
                print(f"Kept: {filename} due to low prediction score.")
                c=c+1
    print(a,b,c)
    '''

    directory = '/home/bamboo/桌面/malware_rl-main (2.0)/malware_rl-main/malware_rl/envs/utils/samples/pe_20200315_filter_7/worm/'  # 恶意dll文件所在目录的路径
    malconv = MalConv()

    a = b = c = 0
    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        bytez = malconv.fetch_file(filepath)
        bytez_np = malconv.extract(bytez)
        prediction = malconv.predict_sample(bytez_np)
        a = a + 1
        print(f"File: {filename}, Prediction: {prediction}")

        # 根据预测结果决定是否删除文件
        if prediction <= malconv.malicious_threshold:
            os.remove(filepath)  # 删除文件
            print(f"Deleted: {filename} due to high prediction score.")
            b = b + 1
        else:
            print(f"Kept: {filename} due to low prediction score.")
            c=c+1
    print(a,b,c)

    def convert_filenames_to_sha256(directory):
        # 遍历目录下的所有文件
        for filename in os.listdir(directory):
            filepath = os.path.join(directory, filename)

            # 如果是文件而不是目录
            if os.path.isfile(filepath):
                # 计算文件名的SHA-256哈希值
                sha256_hash = hashlib.sha256(filename.encode('utf-8')).hexdigest()

                # 构建新的文件名为SHA-256哈希值
                new_filename = sha256_hash

                # 构建新的文件路径
                new_filepath = os.path.join(directory, new_filename)

                # 重命名文件
                os.rename(filepath, new_filepath)
                print(f"Renamed {filename} to {new_filename}")


    # 示例：将目录下的所有文件名转换为SHA-256哈希值
    directory_path = "/home/bamboo/桌面/malware_rl-main (2.0)/malware_rl-main/malware_rl/envs/utils/samples/pe_20200315_filter_7/worm/"  # 替换为实际的目录路径
    convert_filenames_to_sha256(directory_path)


